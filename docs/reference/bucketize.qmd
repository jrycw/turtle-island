# bucketize { #turtle_island.bucketize }

```python
bucketize(*exprs, return_dtype=None)
```

Returns a Polars expression that assigns a label to each row based on its index, cycling through the provided expressions in a round-robin fashion.

`bucketize()` is the more general form of
[bucketize_lit()](bucketize_lit.html#turtle_island.bucketize_lit),
allowing you to pass Polars expressions instead of just literal values.
This enables advanced use cases such as referencing or transforming
existing column values.

::: {.callout-warning}
### Be cautious when using `pl.lit()` as the first expression

Polars will automatically infer the data type of `pl.lit()`. For example, `pl.lit(1)` is inferred as `pl.Int32`.

To avoid unexpected type mismatches, it's recommended to explicitly set the desired data type using `return_dtype=`.
:::

## Parameters {.doc-section .doc-section-parameters}

<code>[**exprs**]{.parameter-name} [:]{.parameter-annotation-sep} [pl.Expr]{.parameter-annotation} [ = ]{.parameter-default-sep} [()]{.parameter-default}</code>

:   Two or more Polars expressions to cycle through. All expressions must resolve to the same data type.

<code>[**return_dtype**]{.parameter-name} [:]{.parameter-annotation-sep} [pl.DataType \| pl.DataTypeExpr \| None]{.parameter-annotation} [ = ]{.parameter-default-sep} [None]{.parameter-default}</code>

:   An optional Polars data type to cast the resulting expression to.

## Returns {.doc-section .doc-section-returns}

<code>[]{.parameter-name} [:]{.parameter-annotation-sep} [pl.Expr]{.parameter-annotation}</code>

:   A Polars expression that cycles through the input expressions based on the row index modulo.

## Examples {.doc-section .doc-section-examples}

Alternate between a column expression and a literal value:
```{python}
import polars as pl
import turtle_island as ti

df = pl.DataFrame({"x": [1, 2, 3, 4, 5]})
df.with_columns(
    ti.bucketize(pl.col("x").add(10), pl.lit(100)).alias("bucketized")
)
```
This alternates between the values of `x + 10` and the literal `100`.
Make sure all expressions resolve to the same typeâ€”in this case, integers.

You can also cast the result to a specific type using `return_dtype=`:
```{python}
df.with_columns(
    ti.bucketize(
        pl.col("x").add(10), pl.lit(100), return_dtype=pl.String
    ).alias("bucketized")
)
```