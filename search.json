[
  {
    "objectID": "articles/intro.html",
    "href": "articles/intro.html",
    "title": "üê¢Turtle Island",
    "section": "",
    "text": "Turtle Island is a lightweight utility library that provides helper functions to reduce boilerplate when writing Polars expressions. It aims to simplify common expression patterns and improve developer productivity when working with the Polars API.\n\n\n\n\n\n\nWarningDisclaimer\n\n\n\nTurtle Island is in early development. The API is still evolving and may change without notice. Use with caution in production environments.\n\n\n\n\nTurtle Island is not yet published on PyPI. The recommended way to install it is using uv add:\nuv add git+https://github.com/jrycw/turtle-island.git\n\n\n\nTo keep your code clean and idiomatic, it‚Äôs recommended to import Turtle Island as a top-level module:\nimport turtle_island as ti\n\n\n\nThe core spirit of Turtle Island is to embrace expressions over columns.\nWhen wrangling data, it‚Äôs common to create temporary helper columns as part of the transformation process. However, many of these columns are just intermediate artifacts ‚Äî not part of the final output we actually want. They exist solely to assist with intermediate steps.\nPolars offers a powerful distinction between contexts and expressions, allowing us to focus on expression-based transformations without needing to materialize every intermediate result as a column. Turtle Island builds on this principle, encouraging users to rely more on expressions ‚Äî flexible, composable, and context-aware ‚Äî rather than temporary columns.\nLet‚Äôs walk through an example to clarify this approach.\n\n\n\nimport polars as pl\nimport turtle_island as ti\n\n\ndf = pl.DataFrame(\n    {\n        \"col1\": [1, 2, 3, 4, 5],\n        \"col2\": [6, 7, 8, 9, 10],\n        \"col3\": [11, 12, 13, 14, 15],\n    }\n)\n\nSay we have a DataFrame df, and we want to transform the values in col1 and col2 such that:\n\nIf the row index is odd (1st, 3rd, ‚Ä¶), the values remain unchanged.\nIf the row index is even (2nd, 4th, ‚Ä¶), the values should be taken from col3.\n\n\n\n\n\n(\n    df.with_row_index().with_columns(\n        pl.when(pl.col(\"index\").mod(2).eq(0))\n        .then(pl.col(\"col1\", \"col2\"))\n        .otherwise(\"col3\"),\n    )\n)\n\n\nshape: (5, 4)indexcol1col2col3u32i64i64i64016111121212238133141414451015\n\n\nIn conventional Polars, achieving this pattern usually involves several steps:\n\nAdd an index column using pl.DataFrame.with_row_index() to track row positions.\nUse a when-then-otherwise expression inside with_columns() to check whether (index % 2) == 0.\n\nBecause the index column must be created first, the conditional logic can only be defined after that step, leading to a step-by-step materialization of intermediate columns.\n\n\n\nWith Turtle Island, you can express the same logic in a single with_columns() context, thanks to expression-based helpers:\n\ndf.with_columns(\n    ti.case_when(\n        case_list=[(ti.is_every_nth_row(2), pl.col(\"col1\", \"col2\"))],\n        otherwise=\"col3\",\n    )\n)\n\n\nshape: (5, 3)col1col2col3i64i64i641611121212381314141451015\n\n\nti.is_every_nth_row() returns a Polars expression rather than a materialized column. Think of it as a virtual column‚Äîyou can use it directly in conditional logic without creating intermediate columns.\nMeanwhile, ti.case_when() offers a cleaner, more ergonomic way to write complex conditions. It‚Äôs optional, but especially useful when handling multiple branches. In practice, I‚Äôve found it far easier to read and maintain than long chains of when-then statements.\n\n\n\n\nSome Turtle Island functions also integrate with Polars‚Äô list namespace, offering a seamless experience. For instance, you can cycle elements downward by one position using ti.cycle() within .list.eval():\n\ndf2 = pl.DataFrame(\n    {\n        \"x\": [[1, 2, 3], [4, 5, 6]],\n        \"y\": [[7, 8, 9], [10, 11, 12]],\n    }\n)\ndf2.with_columns(pl.all().list.eval(ti.cycle(pl.element(), 1)))\n\n\nshape: (2, 2)xylist[i64]list[i64][3, 1, 2][9, 7, 8][6, 4, 5][12, 10, 11]"
  },
  {
    "objectID": "articles/intro.html#installation",
    "href": "articles/intro.html#installation",
    "title": "üê¢Turtle Island",
    "section": "",
    "text": "Turtle Island is not yet published on PyPI. The recommended way to install it is using uv add:\nuv add git+https://github.com/jrycw/turtle-island.git"
  },
  {
    "objectID": "articles/intro.html#recommended-import",
    "href": "articles/intro.html#recommended-import",
    "title": "üê¢Turtle Island",
    "section": "",
    "text": "To keep your code clean and idiomatic, it‚Äôs recommended to import Turtle Island as a top-level module:\nimport turtle_island as ti"
  },
  {
    "objectID": "articles/intro.html#core-spirit",
    "href": "articles/intro.html#core-spirit",
    "title": "üê¢Turtle Island",
    "section": "",
    "text": "The core spirit of Turtle Island is to embrace expressions over columns.\nWhen wrangling data, it‚Äôs common to create temporary helper columns as part of the transformation process. However, many of these columns are just intermediate artifacts ‚Äî not part of the final output we actually want. They exist solely to assist with intermediate steps.\nPolars offers a powerful distinction between contexts and expressions, allowing us to focus on expression-based transformations without needing to materialize every intermediate result as a column. Turtle Island builds on this principle, encouraging users to rely more on expressions ‚Äî flexible, composable, and context-aware ‚Äî rather than temporary columns.\nLet‚Äôs walk through an example to clarify this approach.\n\n\n\nimport polars as pl\nimport turtle_island as ti\n\n\ndf = pl.DataFrame(\n    {\n        \"col1\": [1, 2, 3, 4, 5],\n        \"col2\": [6, 7, 8, 9, 10],\n        \"col3\": [11, 12, 13, 14, 15],\n    }\n)\n\nSay we have a DataFrame df, and we want to transform the values in col1 and col2 such that:\n\nIf the row index is odd (1st, 3rd, ‚Ä¶), the values remain unchanged.\nIf the row index is even (2nd, 4th, ‚Ä¶), the values should be taken from col3.\n\n\n\n\n\n(\n    df.with_row_index().with_columns(\n        pl.when(pl.col(\"index\").mod(2).eq(0))\n        .then(pl.col(\"col1\", \"col2\"))\n        .otherwise(\"col3\"),\n    )\n)\n\n\nshape: (5, 4)indexcol1col2col3u32i64i64i64016111121212238133141414451015\n\n\nIn conventional Polars, achieving this pattern usually involves several steps:\n\nAdd an index column using pl.DataFrame.with_row_index() to track row positions.\nUse a when-then-otherwise expression inside with_columns() to check whether (index % 2) == 0.\n\nBecause the index column must be created first, the conditional logic can only be defined after that step, leading to a step-by-step materialization of intermediate columns.\n\n\n\nWith Turtle Island, you can express the same logic in a single with_columns() context, thanks to expression-based helpers:\n\ndf.with_columns(\n    ti.case_when(\n        case_list=[(ti.is_every_nth_row(2), pl.col(\"col1\", \"col2\"))],\n        otherwise=\"col3\",\n    )\n)\n\n\nshape: (5, 3)col1col2col3i64i64i641611121212381314141451015\n\n\nti.is_every_nth_row() returns a Polars expression rather than a materialized column. Think of it as a virtual column‚Äîyou can use it directly in conditional logic without creating intermediate columns.\nMeanwhile, ti.case_when() offers a cleaner, more ergonomic way to write complex conditions. It‚Äôs optional, but especially useful when handling multiple branches. In practice, I‚Äôve found it far easier to read and maintain than long chains of when-then statements."
  },
  {
    "objectID": "articles/intro.html#add-ons",
    "href": "articles/intro.html#add-ons",
    "title": "üê¢Turtle Island",
    "section": "",
    "text": "Some Turtle Island functions also integrate with Polars‚Äô list namespace, offering a seamless experience. For instance, you can cycle elements downward by one position using ti.cycle() within .list.eval():\n\ndf2 = pl.DataFrame(\n    {\n        \"x\": [[1, 2, 3], [4, 5, 6]],\n        \"y\": [[7, 8, 9], [10, 11, 12]],\n    }\n)\ndf2.with_columns(pl.all().list.eval(ti.cycle(pl.element(), 1)))\n\n\nshape: (2, 2)xylist[i64]list[i64][3, 1, 2][9, 7, 8][6, 4, 5][12, 10, 11]"
  },
  {
    "objectID": "reference/make_index.html",
    "href": "reference/make_index.html",
    "title": "make_index",
    "section": "",
    "text": "make_index(offset=0, *, name='index')\nReturns a Polars expression that creates a virtual row index.\nBorrowed from the Polars documentation and adapted for expression-level use.\nUnlike pl.DataFrame.with_row_index(), which works at the DataFrame level, this expression can be composed inline and reused without materializing an actual column.",
    "crumbs": [
      "API Reference",
      "General",
      "make_index"
    ]
  },
  {
    "objectID": "reference/make_index.html#parameters",
    "href": "reference/make_index.html#parameters",
    "title": "make_index",
    "section": "Parameters",
    "text": "Parameters\n\noffset : int = 0\n\nStart the index at this offset. Cannot be negative.\n\nname : str = 'index'\n\nThe name of the resulting column.",
    "crumbs": [
      "API Reference",
      "General",
      "make_index"
    ]
  },
  {
    "objectID": "reference/make_index.html#returns",
    "href": "reference/make_index.html#returns",
    "title": "make_index",
    "section": "Returns",
    "text": "Returns\n\n : pl.Expr\n\nA Polars expression that yields a sequential integer index starting from 0.",
    "crumbs": [
      "API Reference",
      "General",
      "make_index"
    ]
  },
  {
    "objectID": "reference/make_index.html#examples",
    "href": "reference/make_index.html#examples",
    "title": "make_index",
    "section": "Examples",
    "text": "Examples\n\nDataFrame Context\nAdds a sequential index column to the DataFrame:\n\nimport polars as pl\nimport turtle_island as ti\n\ndf = pl.DataFrame({\"a\": [1, 3, 5], \"b\": [2, 4, 6]})\ndf.select(ti.make_index(), pl.all())\n\n\nshape: (3, 3)indexabu32i64i64012134256",
    "crumbs": [
      "API Reference",
      "General",
      "make_index"
    ]
  },
  {
    "objectID": "reference/shift.html",
    "href": "reference/shift.html",
    "title": "shift",
    "section": "",
    "text": "shift(expr, offset=1, *, fill_expr)\nA variant of pl.Expr.shift() that allows filling shifted values using another Polars expression.",
    "crumbs": [
      "API Reference",
      "General",
      "shift"
    ]
  },
  {
    "objectID": "reference/shift.html#parameters",
    "href": "reference/shift.html#parameters",
    "title": "shift",
    "section": "Parameters",
    "text": "Parameters\n\nexpr : pl.Expr\n\nA single Polars expression to shift.\n\noffset : int = 1\n\nThe number of rows to shift. It must be a non-zero integer. A positive value shifts the column downward (forward), while a negative value shifts it upward (backward).\n\nfill_expr : pl.Expr\n\nExpression used to fill the shifted positions.",
    "crumbs": [
      "API Reference",
      "General",
      "shift"
    ]
  },
  {
    "objectID": "reference/shift.html#returns",
    "href": "reference/shift.html#returns",
    "title": "shift",
    "section": "Returns",
    "text": "Returns\n\n : pl.Expr\n\nA Polars expression with shifted values and custom fill logic.",
    "crumbs": [
      "API Reference",
      "General",
      "shift"
    ]
  },
  {
    "objectID": "reference/shift.html#examples",
    "href": "reference/shift.html#examples",
    "title": "shift",
    "section": "Examples",
    "text": "Examples\n\nDataFrame Context\nShift values downward by 2:\n\nimport polars as pl\nimport turtle_island as ti\n\npl.Config.set_fmt_table_cell_list_len(10)\ndf = pl.DataFrame({\"x\": [1, 2, 3, 4], \"y\": [5, 6, 7, 8]})\ndf.with_columns(\n    ti.shift(pl.col(\"x\"), 2, fill_expr=pl.col(\"y\")).alias(\"shifted\")\n)\n\n\nshape: (4, 3)xyshiftedi64i64i64155266371482\n\n\nShift values upward by 3:\n\ndf.with_columns(\n    ti.shift(pl.col(\"x\"), -3, fill_expr=pl.col(\"y\")).alias(\"shifted\")\n)\n\n\nshape: (4, 3)xyshiftedi64i64i64154266377488\n\n\n\n\nList Namespace Context\n\n\n\n\n\n\nTipWorking with Lists as Series\n\n\n\n\n\nIn the list namespace, it may be easier to think of each row as an element in a list. Conceptually, you‚Äôre working with a pl.Series, where each row corresponds to one item in the list.\n\n\n\nShift values downward by 2:\n\ndf2 = pl.DataFrame(\n    {\n        \"x\": [[1, 2, 3, 4], [5, 6, 7, 8]],\n        \"y\": [[9, 10, 11, 12], [13, 14, 15, 16]],\n    }\n)\ndf2.with_columns(\n    pl.all().list.eval(\n        ti.shift(pl.element(), 2, fill_expr=pl.element().add(10))\n    )\n)\n\n\nshape: (2, 2)xylist[i64]list[i64][11, 12, 1, 2][19, 20, 9, 10][15, 16, 5, 6][23, 24, 13, 14]",
    "crumbs": [
      "API Reference",
      "General",
      "shift"
    ]
  },
  {
    "objectID": "reference/bucketize.html",
    "href": "reference/bucketize.html",
    "title": "bucketize",
    "section": "",
    "text": "bucketize(*exprs, return_dtype=None)\nReturns a Polars expression that assigns a label to each row based on its index, cycling through the provided expressions in a round-robin fashion.\nbucketize() is the more general form of bucketize_lit(), allowing you to pass Polars expressions instead of just literal values. This enables advanced use cases such as referencing or transforming existing column values.",
    "crumbs": [
      "API Reference",
      "General",
      "bucketize"
    ]
  },
  {
    "objectID": "reference/bucketize.html#parameters",
    "href": "reference/bucketize.html#parameters",
    "title": "bucketize",
    "section": "Parameters",
    "text": "Parameters\n\nexprs : pl.Expr | Iterable[pl.Expr] = ()\n\nOne or more pl.Expr objects, which can be passed as separate arguments or as a single iterable containing multiple expressions. All expressions must resolve to the same data type.\n\nreturn_dtype : pl.DataType | pl.DataTypeExpr | None = None\n\nAn optional Polars data type to cast the resulting expression to.",
    "crumbs": [
      "API Reference",
      "General",
      "bucketize"
    ]
  },
  {
    "objectID": "reference/bucketize.html#returns",
    "href": "reference/bucketize.html#returns",
    "title": "bucketize",
    "section": "Returns",
    "text": "Returns\n\n : pl.Expr\n\nA Polars expression that cycles through the input expressions based on the row index modulo.",
    "crumbs": [
      "API Reference",
      "General",
      "bucketize"
    ]
  },
  {
    "objectID": "reference/bucketize.html#examples",
    "href": "reference/bucketize.html#examples",
    "title": "bucketize",
    "section": "Examples",
    "text": "Examples\n\nDataFrame Context\nAlternate between a column expression and a literal value:\n\nimport polars as pl\nimport turtle_island as ti\n\npl.Config.set_fmt_table_cell_list_len(10)\ndf = pl.DataFrame({\"x\": [1, 2, 3, 4, 5]})\ndf.with_columns(\n    ti.bucketize(pl.col(\"x\").add(10), pl.lit(100)).alias(\"bucketized\")\n)\n\n\nshape: (5, 2)xbucketizedi64i6411121003134100515\n\n\nThis alternates between the values of x + 10 and the literal 100. Make sure all expressions resolve to the same type‚Äîin this case, integers.\nYou can also cast the result to a specific type using return_dtype=:\n\ndf.with_columns(\n    ti.bucketize(\n        pl.col(\"x\").add(10), pl.lit(100), return_dtype=pl.String\n    ).alias(\"bucketized\")\n)\n\n\nshape: (5, 2)xbucketizedi64str1\"11\"2\"100\"3\"13\"4\"100\"5\"15\"\n\n\n\n\nList Namespace Context\n\n\n\n\n\n\nTipWorking with Lists as Series\n\n\n\n\n\nIn the list namespace, it may be easier to think of each row as an element in a list. Conceptually, you‚Äôre working with a pl.Series, where each row corresponds to one item in the list.\n\n\n\nAlternate between a column expression and a literal value for each element:\n\ndf2 = pl.DataFrame(\n    {\n        \"x\": [[1, 2, 3, 4], [5, 6, 7, 8]],\n        \"y\": [[9, 10, 11, 12], [13, 14, 15, 16]],\n    }\n)\n(\ndf2.with_columns(\n        pl.all().list.eval(ti.bucketize(pl.element().add(10), pl.lit(100)))\n    )\n)\n\n\nshape: (2, 2)xylist[i64]list[i64][11, 100, 13, 100][19, 100, 21, 100][15, 100, 17, 100][23, 100, 25, 100]",
    "crumbs": [
      "API Reference",
      "General",
      "bucketize"
    ]
  },
  {
    "objectID": "reference/make_concat_str.html",
    "href": "reference/make_concat_str.html",
    "title": "make_concat_str",
    "section": "",
    "text": "make_concat_str(template, *col_names, sep='[$X]', name='literal')\nConstruct a concatenated string expression by treating column names as placeholders within a template string.\nThis function simplifies string concatenation by allowing users to insert column values into a string template using a custom separator (sep=). It‚Äôs particularly useful when constructing long strings like HTML content.\nInternally, make_concat_str() splits the template= string based on the sep= value, then interleaves the literals with the specified column names using pl.concat_str().",
    "crumbs": [
      "API Reference",
      "General",
      "make_concat_str"
    ]
  },
  {
    "objectID": "reference/make_concat_str.html#parameters",
    "href": "reference/make_concat_str.html#parameters",
    "title": "make_concat_str",
    "section": "Parameters",
    "text": "Parameters\n\ntemplate : str\n\nA string template where column placeholders are defined using the sep= string. Users are responsible for choosing a safe separator that won‚Äôt conflict with existing text. Common separators like ‚Äú,‚Äù or ‚Äú;‚Äù may cause issues if they appear elsewhere in the template.\n\ncol_names : str = ()\n\nOne or more column names to inject into the template string. These will be inserted at positions marked by sep=.\n\nsep : str = '[$X]'\n\nThe placeholder used to indicate where column names should be inserted within the template.\n\nname : str = 'literal'\n\nThe name of the resulting column.",
    "crumbs": [
      "API Reference",
      "General",
      "make_concat_str"
    ]
  },
  {
    "objectID": "reference/make_concat_str.html#returns",
    "href": "reference/make_concat_str.html#returns",
    "title": "make_concat_str",
    "section": "Returns",
    "text": "Returns\n\n : pl.Expr\n\nA Polars expression representing the final concatenated string.",
    "crumbs": [
      "API Reference",
      "General",
      "make_concat_str"
    ]
  },
  {
    "objectID": "reference/make_concat_str.html#examples",
    "href": "reference/make_concat_str.html#examples",
    "title": "make_concat_str",
    "section": "Examples",
    "text": "Examples\n\nDataFrame Context\nHere‚Äôs an example that builds an HTML &lt;p&gt; tag from a DataFrame:\n\nimport polars as pl\nimport turtle_island as ti\n\npl.Config.set_fmt_str_lengths(200)\ndf = pl.DataFrame({\"text\": [\"This is a simple paragraph of text.\"]})\nstyle = 'style=\"color: steelblue;\"'\nnew_df = df.with_columns(\n    ti.make_concat_str(f\"&lt;p {style}&gt;[$X]&lt;/p&gt;\", \"text\", name=\"p_tag\")\n)\nnew_df\n\n\nshape: (1, 2)textp_tagstrstr\"This is a simple paragraph of text.\"\"&lt;p style=\"color: steelblue;\"&gt;This is a simple paragraph of text.&lt;/p&gt;\"\n\n\n\nnew_df.style\n\n\n\n\n\n\n\n  text\n  p_tag\n\n\n\n  \n    This is a simple paragraph of text.\n    This is a simple paragraph of text.\n  \n\n\n\n\n\n\n        \n\n\nDid you notice that style is just a regular Python variable?\nWe‚Äôre dynamically injecting it with an f-string before passing it to make_concat_str().",
    "crumbs": [
      "API Reference",
      "General",
      "make_concat_str"
    ]
  },
  {
    "objectID": "reference/bulk_append.html",
    "href": "reference/bulk_append.html",
    "title": "bulk_append",
    "section": "",
    "text": "bulk_append(*exprs)\nCombines multiple Polars expressions using pl.Expr.append() internally.",
    "crumbs": [
      "API Reference",
      "General",
      "bulk_append"
    ]
  },
  {
    "objectID": "reference/bulk_append.html#parameters",
    "href": "reference/bulk_append.html#parameters",
    "title": "bulk_append",
    "section": "Parameters",
    "text": "Parameters\n\nexprs : pl.Expr | Iterable[pl.Expr] = ()\n\nOne or more pl.Expr objects passed as separate arguments, or a single iterable containing multiple pl.Expr objects.",
    "crumbs": [
      "API Reference",
      "General",
      "bulk_append"
    ]
  },
  {
    "objectID": "reference/bulk_append.html#returns",
    "href": "reference/bulk_append.html#returns",
    "title": "bulk_append",
    "section": "Returns",
    "text": "Returns\n\n : pl.Expr\n\nA single Polars expression resulting from appending all input expressions.",
    "crumbs": [
      "API Reference",
      "General",
      "bulk_append"
    ]
  },
  {
    "objectID": "reference/bulk_append.html#examples",
    "href": "reference/bulk_append.html#examples",
    "title": "bulk_append",
    "section": "Examples",
    "text": "Examples\n\nDataFrame Context\n\n\n\n\n\n\nCautionCaution When Used in with_columns() Context\n\n\n\n\n\nBecause bulk_append() may change the total number of rows, use it with caution inside with_columns().\n\n\n\nAppend the last value to the first:\n\nimport polars as pl\nimport turtle_island as ti\n\ndf = pl.DataFrame(\n    {\"a\": [1, 2, 3], \"b\": [\"x\", \"y\", \"z\"], \"c\": [4.4, 5.5, 6.6]}\n)\ndf.select(ti.bulk_append(pl.all().first(), pl.all().last()))\n\n\nshape: (2, 3)abci64strf641\"x\"4.43\"z\"6.6\n\n\n\n\nList Namespace Context\n\n\n\n\n\n\nTipWorking with Lists as Series\n\n\n\n\n\nIn the list namespace, it may be easier to think of each row as an element in a list. Conceptually, you‚Äôre working with a pl.Series, where each row corresponds to one item in the list.\n\n\n\nA similar operation applies to lists, where the last element is appended to the first.\n\ndf2 = pl.DataFrame(\n    {\n        \"x\": [[1, 2, 3, 4], [5, 6, 7, 8]],\n        \"y\": [[9, 10, 11, 12], [13, 14, 15, 16]],\n    }\n)\ndf2.select(\n    pl.all().list.eval(\n        ti.bulk_append(pl.element().first(), pl.element().last())\n    )\n)\n\n\nshape: (2, 2)xylist[i64]list[i64][1, 4][9, 12][5, 8][13, 16]",
    "crumbs": [
      "API Reference",
      "General",
      "bulk_append"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "API Reference",
    "section": "",
    "text": "Expressions for general-purpose data transformation.\n\n\n\nbulk_append\nCombines multiple Polars expressions using pl.Expr.append() internally.\n\n\nbucketize\nReturns a Polars expression that assigns a label to each row based on its index, cycling through the provided expressions in a round-robin fashion.\n\n\nbucketize_lit\nReturns a Polars expression that assigns a label to each row based on its index, cycling through the provided items in a round-robin fashion.\n\n\ncase_when\nSimplifies conditional logic in Polars by chaining multiple when-then-otherwise expressions.\n\n\ncycle\nReturn a Polars expression that cycles the rows by a given offset.\n\n\nis_every_nth_row\nReturns a Polars expression that is True for every n-th row (index modulo n equals 0).\n\n\nprepend\nReturns a Polars expression that prepends rows using the prepend_expr= parameter.\n\n\nshift\nA variant of pl.Expr.shift() that allows filling shifted values using another Polars expression.\n\n\nmake_concat_str\nConstruct a concatenated string expression by treating column names as placeholders within a template string.\n\n\nmake_index\nReturns a Polars expression that creates a virtual row index.\n\n\nmove_cols_to_end\nReturns a list of Polars expressions that reorder columns so the specified columns appear last.\n\n\nmove_cols_to_start\nReturns a list of Polars expressions that reorder columns so the specified columns appear first.\n\n\n\n\n\n\nExpressions for generating HTML tags.\n\n\n\nmake_hyperlink\nReturns a Polars expression that generates an HTML hyperlink (&lt;a&gt; tag) for each row.\n\n\nmake_tooltip\nReturns a Polars expression that generates an HTML tooltip for each row.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "reference/index.html#general",
    "href": "reference/index.html#general",
    "title": "API Reference",
    "section": "",
    "text": "Expressions for general-purpose data transformation.\n\n\n\nbulk_append\nCombines multiple Polars expressions using pl.Expr.append() internally.\n\n\nbucketize\nReturns a Polars expression that assigns a label to each row based on its index, cycling through the provided expressions in a round-robin fashion.\n\n\nbucketize_lit\nReturns a Polars expression that assigns a label to each row based on its index, cycling through the provided items in a round-robin fashion.\n\n\ncase_when\nSimplifies conditional logic in Polars by chaining multiple when-then-otherwise expressions.\n\n\ncycle\nReturn a Polars expression that cycles the rows by a given offset.\n\n\nis_every_nth_row\nReturns a Polars expression that is True for every n-th row (index modulo n equals 0).\n\n\nprepend\nReturns a Polars expression that prepends rows using the prepend_expr= parameter.\n\n\nshift\nA variant of pl.Expr.shift() that allows filling shifted values using another Polars expression.\n\n\nmake_concat_str\nConstruct a concatenated string expression by treating column names as placeholders within a template string.\n\n\nmake_index\nReturns a Polars expression that creates a virtual row index.\n\n\nmove_cols_to_end\nReturns a list of Polars expressions that reorder columns so the specified columns appear last.\n\n\nmove_cols_to_start\nReturns a list of Polars expressions that reorder columns so the specified columns appear first.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "reference/index.html#html",
    "href": "reference/index.html#html",
    "title": "API Reference",
    "section": "",
    "text": "Expressions for generating HTML tags.\n\n\n\nmake_hyperlink\nReturns a Polars expression that generates an HTML hyperlink (&lt;a&gt; tag) for each row.\n\n\nmake_tooltip\nReturns a Polars expression that generates an HTML tooltip for each row.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "reference/move_cols_to_end.html",
    "href": "reference/move_cols_to_end.html",
    "title": "move_cols_to_end",
    "section": "",
    "text": "move_cols_to_end(columns, *more_columns)\nReturns a list of Polars expressions that reorder columns so the specified columns appear last.",
    "crumbs": [
      "API Reference",
      "General",
      "move_cols_to_end"
    ]
  },
  {
    "objectID": "reference/move_cols_to_end.html#parameters",
    "href": "reference/move_cols_to_end.html#parameters",
    "title": "move_cols_to_end",
    "section": "Parameters",
    "text": "Parameters\n\ncolumns : str | PolarsDataType | Collection[str] | Collection[PolarsDataType]\n\nThe name or datatype of the column(s) to move. Accepts regular expression input. Regular expressions should start with ^ and end with $.\n\n*more_columns : str | PolarsDataType = ()\n\nAdditional names or datatypes of columns to move, specified as positional arguments.",
    "crumbs": [
      "API Reference",
      "General",
      "move_cols_to_end"
    ]
  },
  {
    "objectID": "reference/move_cols_to_end.html#returns",
    "href": "reference/move_cols_to_end.html#returns",
    "title": "move_cols_to_end",
    "section": "Returns",
    "text": "Returns\n\n : list[pl.Expr]\n\nA list of expressions to reorder columns.",
    "crumbs": [
      "API Reference",
      "General",
      "move_cols_to_end"
    ]
  },
  {
    "objectID": "reference/move_cols_to_end.html#examples",
    "href": "reference/move_cols_to_end.html#examples",
    "title": "move_cols_to_end",
    "section": "Examples",
    "text": "Examples\n\nDataFrame Context\n\n\n\n\n\n\nCautionWorks Only in select() Context\n\n\n\n\n\nThe list of expressions returned by move_cols_to_end() take effect only within the select() context. Using them in with_columns() will have no effect, and the result will remain unchanged.\n\n\n\n\nimport polars as pl\nimport turtle_island as ti\n\ndf = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [\"x\", \"y\", \"z\"], \"c\": [4.4, 5.5, 6.6]})\ndf\n\n\nshape: (3, 3)abci64strf641\"x\"4.42\"y\"5.53\"z\"6.6\n\n\nReorder columns so that selected columns appear last:\n\ndf.select(ti.move_cols_to_end(\"b\", \"a\"))\n\n\nshape: (3, 3)cbaf64stri644.4\"x\"15.5\"y\"26.6\"z\"3\n\n\nReorder by data type:\n\ndf.select(ti.move_cols_to_end([pl.String, pl.Int64]))\n\n\nshape: (3, 3)cabf64i64str4.41\"x\"5.52\"y\"6.63\"z\"\n\n\nNote that when selecting by data type, the moved columns will follow the original order in the DataFrame schema.\n\ndf.select(ti.move_cols_to_end([pl.Int64, pl.String]))\n\n\nshape: (3, 3)cabf64i64str4.41\"x\"5.52\"y\"6.63\"z\"",
    "crumbs": [
      "API Reference",
      "General",
      "move_cols_to_end"
    ]
  },
  {
    "objectID": "reference/make_tooltip.html",
    "href": "reference/make_tooltip.html",
    "title": "make_tooltip",
    "section": "",
    "text": "make_tooltip(\n    label,\n    tooltip,\n    text_decoration_style='dotted',\n    color='blue',\n    *,\n    name='tooltip',\n)\nReturns a Polars expression that generates an HTML tooltip for each row.",
    "crumbs": [
      "API Reference",
      "HTML",
      "make_tooltip"
    ]
  },
  {
    "objectID": "reference/make_tooltip.html#parameters",
    "href": "reference/make_tooltip.html#parameters",
    "title": "make_tooltip",
    "section": "Parameters",
    "text": "Parameters\n\nlabel : str\n\nColumn name containing the main text to display.\n\ntooltip : str\n\nColumn name containing containing the text shown when hovering over the label.\n\ntext_decoration_style : Literal['solid', 'dotted', 'none'] = 'dotted'\n\nA string indicating the style of underline decoration. Options are \"solid\", \"dotted\", or \"none\".\n\ncolor : str | Literal['none'] = 'blue'\n\nA string indicating the text color. If ‚Äúnone‚Äù, no color styling is applied.\n\nname : str = 'tooltip'\n\nThe name of the resulting column.",
    "crumbs": [
      "API Reference",
      "HTML",
      "make_tooltip"
    ]
  },
  {
    "objectID": "reference/make_tooltip.html#returns",
    "href": "reference/make_tooltip.html#returns",
    "title": "make_tooltip",
    "section": "Returns",
    "text": "Returns\n\n : pl.Expr\n\nA Polars expression that creates an HTML string with tooltip functionality.",
    "crumbs": [
      "API Reference",
      "HTML",
      "make_tooltip"
    ]
  },
  {
    "objectID": "reference/make_tooltip.html#examples",
    "href": "reference/make_tooltip.html#examples",
    "title": "make_tooltip",
    "section": "Examples",
    "text": "Examples\n\nDataFrame Context\n\nimport polars as pl\nimport turtle_island as ti\n\npl.Config.set_fmt_str_lengths(200)\ndf = pl.DataFrame(\n    {\n        \"name\": [\"Turtle Island\"],\n        \"description\": [\"A Utility Kit for Polars Expressions\"],\n    }\n)\nnew_df = df.with_columns(ti.make_tooltip(\"name\", \"description\"))\nnew_df\n\n\nshape: (1, 3)namedescriptiontooltipstrstrstr\"Turtle Island\"\"A Utility Kit for Polars Expressions\"\"&lt;abbr style=\"cursor: help; text-decoration: underline; text-decoration-style: dotted; color: blue; \" title=\"A Utility Kit for Polars Expressions\"&gt;Turtle Island&lt;/abbr&gt;\"\n\n\n\nnew_df.style\n\n\n\n\n\n\n\n  name\n  description\n  tooltip\n\n\n\n  \n    Turtle Island\n    A Utility Kit for Polars Expressions\n    Turtle Island",
    "crumbs": [
      "API Reference",
      "HTML",
      "make_tooltip"
    ]
  },
  {
    "objectID": "reference/make_hyperlink.html",
    "href": "reference/make_hyperlink.html",
    "title": "make_hyperlink",
    "section": "",
    "text": "make_hyperlink(text, url, new_tab=True, *, name='hyperlink')\nReturns a Polars expression that generates an HTML hyperlink (&lt;a&gt; tag) for each row.",
    "crumbs": [
      "API Reference",
      "HTML",
      "make_hyperlink"
    ]
  },
  {
    "objectID": "reference/make_hyperlink.html#parameters",
    "href": "reference/make_hyperlink.html#parameters",
    "title": "make_hyperlink",
    "section": "Parameters",
    "text": "Parameters\n\ntext : str\n\nColumn name containing the display text for the hyperlink.\n\nurl : str\n\nColumn name containing the destination URL.\n\nnew_tab : bool = True\n\nWhether the link opens in a new browser tab (target=\"_blank\") or the current tab.\n\nname : str = 'hyperlink'\n\nThe name of the resulting column.",
    "crumbs": [
      "API Reference",
      "HTML",
      "make_hyperlink"
    ]
  },
  {
    "objectID": "reference/make_hyperlink.html#returns",
    "href": "reference/make_hyperlink.html#returns",
    "title": "make_hyperlink",
    "section": "Returns",
    "text": "Returns\n\n : pl.Expr\n\nA Polars expression generating the HTML anchor tag.",
    "crumbs": [
      "API Reference",
      "HTML",
      "make_hyperlink"
    ]
  },
  {
    "objectID": "reference/make_hyperlink.html#examples",
    "href": "reference/make_hyperlink.html#examples",
    "title": "make_hyperlink",
    "section": "Examples",
    "text": "Examples\n\nDataFrame Context\nCreate an HTML anchor tag (&lt;a&gt;) combining link text and URL from two columns:\n\nimport polars as pl\nimport turtle_island as ti\n\npl.Config.set_fmt_str_lengths(200)\ndf = pl.DataFrame(\n    {\n        \"name\": [\"Turtle Island\"],\n        \"url\": [\"https://github.com/jrycw/turtle-island\"],\n    }\n)\nnew_df = df.with_columns(ti.make_hyperlink(\"name\", \"url\"))\nnew_df\n\n\nshape: (1, 3)nameurlhyperlinkstrstrstr\"Turtle Island\"\"https://github.com/jrycw/turtle-island\"\"&lt;a href=\"https://github.com/jrycw/turtle-island\" target=\"_blank\"&gt;Turtle Island&lt;/a&gt;\"\n\n\n\nnew_df.style\n\n\n\n\n\n\n\n  name\n  url\n  hyperlink\n\n\n\n  \n    Turtle Island\n    https://github.com/jrycw/turtle-island\n    Turtle Island",
    "crumbs": [
      "API Reference",
      "HTML",
      "make_hyperlink"
    ]
  },
  {
    "objectID": "reference/prepend.html",
    "href": "reference/prepend.html",
    "title": "prepend",
    "section": "",
    "text": "prepend(expr, offset=1, *, prepend_expr=None)\nReturns a Polars expression that prepends rows using the prepend_expr= parameter.\nIf prepend_expr= is not provided, the first row(s) of the current DataFrame‚Äîor Series if used within the list namespace‚Äîwill be used by default, based on the offset= value.",
    "crumbs": [
      "API Reference",
      "General",
      "prepend"
    ]
  },
  {
    "objectID": "reference/prepend.html#parameters",
    "href": "reference/prepend.html#parameters",
    "title": "prepend",
    "section": "Parameters",
    "text": "Parameters\n\nexpr : pl.Expr\n\nA Polars expression to which rows will be prepended.\n\noffset : int = 1\n\nNumber of rows to prepend. Must be a positive integer.\n\nprepend_expr : pl.Expr | None = None\n\nThe expression to prepend.",
    "crumbs": [
      "API Reference",
      "General",
      "prepend"
    ]
  },
  {
    "objectID": "reference/prepend.html#returns",
    "href": "reference/prepend.html#returns",
    "title": "prepend",
    "section": "Returns",
    "text": "Returns\n\n : pl.Expr\n\nA Polars expression with the specified values prepended.",
    "crumbs": [
      "API Reference",
      "General",
      "prepend"
    ]
  },
  {
    "objectID": "reference/prepend.html#examples",
    "href": "reference/prepend.html#examples",
    "title": "prepend",
    "section": "Examples",
    "text": "Examples\n\nDataFrame Context\n\n\n\n\n\n\nCautionCannot be used in the with_columns() context\n\n\n\n\n\nBecause prepend() modifies the total number of rows, it cannot be used inside with_columns().\n\n\n\nPrepend one row using the default behavior:\n\nimport polars as pl\nimport turtle_island as ti\n\npl.Config.set_fmt_table_cell_list_len(10)\ndf = pl.DataFrame({\"x\": [1, 2, 3, 4], \"y\": [5, 6, 7, 8]})\ndf.select(ti.prepend(pl.all()))\n\n\nshape: (5, 2)xyi64i641515263748\n\n\nPrepend two rows using a literal value:\n\ndf.select(\n    ti.prepend(pl.all(), offset=2, prepend_expr=pl.lit(0))\n)\n\n\nshape: (6, 2)xyi64i64000015263748\n\n\nPrepend two rows using a custom expression:\n\ndf.select(\n    ti.prepend(pl.all(), offset=3, prepend_expr=pl.col(\"x\").mul(pl.col(\"y\")))\n)\n\n\nshape: (7, 2)xyi64i64551212212115263748\n\n\n\n\nList Namespace Context\n\n\n\n\n\n\nTipWorking with Lists as Series\n\n\n\n\n\nIn the list namespace, it may be easier to think of each row as an element in a list. Conceptually, you‚Äôre working with a pl.Series, where each row corresponds to one item in the list.\n\n\n\nPrepend one element to each list:\n\ndf2 = pl.DataFrame(\n    {\n        \"x\": [[1, 2, 3, 4], [5, 6, 7, 8]],\n        \"y\": [[9, 10, 11, 12], [13, 14, 15, 16]],\n    }\n)\ndf2.select(pl.all().list.eval(ti.prepend(pl.element())))\n\n\nshape: (2, 2)xylist[i64]list[i64][1, 1, 2, 3, 4][9, 9, 10, 11, 12][5, 5, 6, 7, 8][13, 13, 14, 15, 16]\n\n\nPrepend two elements using a literal value:\n\ndf2.select(\n    pl.all().list.eval(\n        ti.prepend(pl.element(), offset=2, prepend_expr=pl.lit(0))\n    )\n)\n\n\nshape: (2, 2)xylist[i64]list[i64][0, 0, 1, 2, 3, 4][0, 0, 9, 10, 11, 12][0, 0, 5, 6, 7, 8][0, 0, 13, 14, 15, 16]\n\n\nPrepend three elements using a custom expression:\n\ndf2.select(\n    pl.all().list.eval(\n        ti.prepend(pl.element(), offset=3, prepend_expr=pl.element().add(10))\n    )\n)\n\n\nshape: (2, 2)xylist[i64]list[i64][11, 12, 13, 1, 2, 3, 4][19, 20, 21, 9, 10, 11, 12][15, 16, 17, 5, 6, 7, 8][23, 24, 25, 13, 14, 15, 16]\n\n\nPrepend five elements using a literal value.\n\ndf2.select(\n    pl.all()\n    .list.eval(ti.prepend(pl.element(), offset=4, prepend_expr=pl.lit(0)))\n    .list.eval(ti.prepend(pl.element(), offset=1, prepend_expr=pl.lit(0)))\n)\n\n\nshape: (2, 2)xylist[i64]list[i64][0, 0, 0, 0, 0, 1, 2, 3, 4][0, 0, 0, 0, 0, 9, 10, 11, 12][0, 0, 0, 0, 0, 5, 6, 7, 8][0, 0, 0, 0, 0, 13, 14, 15, 16]\n\n\nIn this case, the number of elements to prepend (5) exceeds the number of elements in each list (4), so you need to call prepend() twice in separate .list.eval() steps to achieve the desired result.\nYou can also approach this by using bulk_append() to achieve the same result:\n\ndf2.select(pl.all().list.eval(ti.bulk_append(pl.repeat(0, 5), pl.element())))\n\n\nshape: (2, 2)xylist[i64]list[i64][0, 0, 0, 0, 0, 1, 2, 3, 4][0, 0, 0, 0, 0, 9, 10, 11, 12][0, 0, 0, 0, 0, 5, 6, 7, 8][0, 0, 0, 0, 0, 13, 14, 15, 16]\n\n\n\n\n\n\n\n\nNoteWhy bulk_append() is not used to implement prepend()\n\n\n\n\n\n\nIf prepend_value= is an expression rather than a literal, there‚Äôs no reliable way to determine how many times the expression should be prepended dynamically.\nThis approach only works within the list namespace. Aliases appear to have no effect in this context. For example, pl.repeat() typically carries a ‚Äúliteral‚Äù alias in the DataFrame context, which makes it difficult to programmatically substitute it with the original column name‚Äîespecially when supporting wildcards like pl.all() or pl.col(\"*\").",
    "crumbs": [
      "API Reference",
      "General",
      "prepend"
    ]
  },
  {
    "objectID": "reference/cycle.html",
    "href": "reference/cycle.html",
    "title": "cycle",
    "section": "",
    "text": "cycle(expr, offset=1)\nReturn a Polars expression that cycles the rows by a given offset.",
    "crumbs": [
      "API Reference",
      "General",
      "cycle"
    ]
  },
  {
    "objectID": "reference/cycle.html#parameters",
    "href": "reference/cycle.html#parameters",
    "title": "cycle",
    "section": "Parameters",
    "text": "Parameters\n\nexpr : \n\nA single Polars expression to apply the cycling operation on.\n\noffset : int = 1\n\nThe number of rows to cycle by. Positive values shift rows downward, and negative values shift rows upward.",
    "crumbs": [
      "API Reference",
      "General",
      "cycle"
    ]
  },
  {
    "objectID": "reference/cycle.html#returns",
    "href": "reference/cycle.html#returns",
    "title": "cycle",
    "section": "Returns",
    "text": "Returns\n\n : pl.Expr\n\nA Polars expression with values cyclically shifted.",
    "crumbs": [
      "API Reference",
      "General",
      "cycle"
    ]
  },
  {
    "objectID": "reference/cycle.html#examples",
    "href": "reference/cycle.html#examples",
    "title": "cycle",
    "section": "Examples",
    "text": "Examples\n\nDataFrame Context\nCycle downward by 2 rows:\n\nimport polars as pl\nimport turtle_island as ti\n\npl.Config.set_fmt_table_cell_list_len(10)\ndf = pl.DataFrame({\"x\": [1, 2, 3, 4]})\ndf.with_columns(ti.cycle(pl.col(\"x\"), 2).alias(\"cycle\"))\n\n\nshape: (4, 2)xcyclei64i6413243142\n\n\nCycle upward by 4 rows (no visible change due to full cycle):\n\ndf.with_columns(ti.cycle(pl.col(\"x\"), -4).alias(\"cycle\"))\n\n\nshape: (4, 2)xcyclei64i6411223344\n\n\n\n\nList Namespace Context\n\n\n\n\n\n\nTipWorking with Lists as Series\n\n\n\n\n\nIn the list namespace, it may be easier to think of each row as an element in a list. Conceptually, you‚Äôre working with a pl.Series, where each row corresponds to one item in the list.\n\n\n\nCycle downward by 2 elements:\n\ndf2 = pl.DataFrame(\n    {\n        \"x\": [[1, 2, 3, 4], [5, 6, 7, 8]],\n        \"y\": [[9, 10, 11, 12], [13, 14, 15, 16]],\n    }\n)\ndf2.with_columns(pl.all().list.eval(ti.cycle(pl.element(), 2)))\n\n\nshape: (2, 2)xylist[i64]list[i64][3, 4, 1, 2][11, 12, 9, 10][7, 8, 5, 6][15, 16, 13, 14]",
    "crumbs": [
      "API Reference",
      "General",
      "cycle"
    ]
  },
  {
    "objectID": "reference/case_when.html",
    "href": "reference/case_when.html",
    "title": "case_when",
    "section": "",
    "text": "case_when(case_list, otherwise=None)\nSimplifies conditional logic in Polars by chaining multiple when-then-otherwise expressions.\nInspired by pd.Series.case_when(), this function offers a more ergonomic way to express chained conditional logic with Polars expressions.",
    "crumbs": [
      "API Reference",
      "General",
      "case_when"
    ]
  },
  {
    "objectID": "reference/case_when.html#parameters",
    "href": "reference/case_when.html#parameters",
    "title": "case_when",
    "section": "Parameters",
    "text": "Parameters\n\ncase_list : Sequence[tuple[pl.Expr | tuple[pl.Expr], pl.Expr]]\n\nA sequence of tuples where each tuple represents a when and then branch. This function accepts three input forms (see examples below). Each tuple is evaluated in order from top to bottom. For each tuple, the expressions before the final element are treated as when conditions and combined with &. If the combined condition evaluates to True, the corresponding then expression (the last element) is returned and the evaluation stops. If no condition matches any tuple, the otherwise expression is used as the fallback.\n\notherwise : pl.Expr | None = None\n\nFallback expression used when no conditions match.",
    "crumbs": [
      "API Reference",
      "General",
      "case_when"
    ]
  },
  {
    "objectID": "reference/case_when.html#returns",
    "href": "reference/case_when.html#returns",
    "title": "case_when",
    "section": "Returns",
    "text": "Returns\n\n : pl.Expr\n\nA single Polars expression suitable for use in transformations.",
    "crumbs": [
      "API Reference",
      "General",
      "case_when"
    ]
  },
  {
    "objectID": "reference/case_when.html#examples",
    "href": "reference/case_when.html#examples",
    "title": "case_when",
    "section": "Examples",
    "text": "Examples\n\nDataFrame Context\nThe example below demonstrates all three supported input forms.\nexpr1 uses the simplest form, where each tuple contains a single when condition followed by its corresponding then expression.\nexpr2 shows tuples with multiple when conditions listed before the final then expression. These conditions are implicitly combined with &.\nexpr3 uses a tuple as the first element of each tuple, containing multiple when conditions which are also combined with & before evaluation.\n\nimport polars as pl\nimport turtle_island as ti\n\ndf = pl.DataFrame({\"x\": [1, 2, 3, 4], \"y\": [5, 6, 7, 8]})\n\nexpr1 = ti.case_when(\n    case_list=[\n        (pl.col(\"x\") &lt; 2, pl.lit(\"small\")),\n        (pl.col(\"x\") &lt; 4, pl.lit(\"medium\")),\n    ],\n    otherwise=pl.lit(\"large\"),\n).alias(\"size1\")\n\nexpr2 = ti.case_when(\n    case_list=[\n        (pl.col(\"x\") &lt; 3, pl.col(\"y\") &lt; 6, pl.lit(\"small\")),\n        (pl.col(\"x\") &lt; 4, pl.col(\"y\") &lt; 8, pl.lit(\"medium\")),\n    ],\n    otherwise=pl.lit(\"large\"),\n).alias(\"size2\")\n\nexpr3 = ti.case_when(\n    case_list=[\n        ((pl.col(\"x\") &lt; 3, pl.col(\"y\") &lt; 6), pl.lit(\"small\")),\n        ((pl.col(\"x\") &lt; 4, pl.col(\"y\") &lt; 8), pl.lit(\"medium\")),\n    ],\n    otherwise=pl.lit(\"large\"),\n).alias(\"size3\")\n\ndf.with_columns(expr1, expr2, expr3)\n\n\nshape: (4, 5)xysize1size2size3i64i64strstrstr15\"small\"\"small\"\"small\"26\"medium\"\"medium\"\"medium\"37\"medium\"\"medium\"\"medium\"48\"large\"\"large\"\"large\"\n\n\n\n\nList Namespace Context\n\n\n\n\n\n\nTipWorking with Lists as Series\n\n\n\n\n\nIn the list namespace, it may be easier to think of each row as an element in a list. Conceptually, you‚Äôre working with a pl.Series, where each row corresponds to one item in the list.\n\n\n\nCheck whether each string in the list starts with the letter ‚Äúa‚Äù or ‚ÄúA‚Äù:\n\ndf2 = pl.DataFrame(\n    {\n        \"col1\": [\n            [\"orange\", \"Lemon\", \"Kiwi\"],\n            [\"Acerola\", \"Cherry\", \"Papaya\"],\n        ],\n        \"col2\": [\n            [\"Grape\", \"Avocado\", \"apricot\"],\n            [\"Banana\", \"apple\", \"Mango\"],\n        ],\n    }\n)\n\ncase_list = [\n    (pl.element().str.to_lowercase().str.starts_with(\"a\"), pl.lit(\"Y\"))\n]\notherwise = pl.lit(\"N\")\n\n(df2.with_columns(pl.all().list.eval(ti.case_when(case_list, otherwise))))\n\n\nshape: (2, 2)col1col2list[str]list[str][\"N\", \"N\", \"N\"][\"N\", \"Y\", \"Y\"][\"Y\", \"N\", \"N\"][\"N\", \"Y\", \"N\"]",
    "crumbs": [
      "API Reference",
      "General",
      "case_when"
    ]
  },
  {
    "objectID": "reference/move_cols_to_start.html",
    "href": "reference/move_cols_to_start.html",
    "title": "move_cols_to_start",
    "section": "",
    "text": "move_cols_to_start(columns, *more_columns)\nReturns a list of Polars expressions that reorder columns so the specified columns appear first.",
    "crumbs": [
      "API Reference",
      "General",
      "move_cols_to_start"
    ]
  },
  {
    "objectID": "reference/move_cols_to_start.html#parameters",
    "href": "reference/move_cols_to_start.html#parameters",
    "title": "move_cols_to_start",
    "section": "Parameters",
    "text": "Parameters\n\ncolumns : str | PolarsDataType | Collection[str] | Collection[PolarsDataType]\n\nThe name or datatype of the column(s) to move. Accepts regular expression input. Regular expressions should start with ^ and end with $.\n\n*more_columns : str | PolarsDataType = ()\n\nAdditional names or datatypes of columns to move, specified as positional arguments.",
    "crumbs": [
      "API Reference",
      "General",
      "move_cols_to_start"
    ]
  },
  {
    "objectID": "reference/move_cols_to_start.html#returns",
    "href": "reference/move_cols_to_start.html#returns",
    "title": "move_cols_to_start",
    "section": "Returns",
    "text": "Returns\n\n : list[pl.Expr]\n\nA list of expressions to reorder columns.",
    "crumbs": [
      "API Reference",
      "General",
      "move_cols_to_start"
    ]
  },
  {
    "objectID": "reference/move_cols_to_start.html#examples",
    "href": "reference/move_cols_to_start.html#examples",
    "title": "move_cols_to_start",
    "section": "Examples",
    "text": "Examples\n\nDataFrame Context\n\n\n\n\n\n\nCautionWorks Only in select() Context\n\n\n\n\n\nThe list of expressions returned by move_cols_to_start() take effect only within the select() context. Using them in with_columns() will have no effect, and the result will remain unchanged.\n\n\n\n\nimport polars as pl\nimport turtle_island as ti\n\ndf = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [\"x\", \"y\", \"z\"], \"c\": [4.4, 5.5, 6.6]})\ndf\n\n\nshape: (3, 3)abci64strf641\"x\"4.42\"y\"5.53\"z\"6.6\n\n\nReorder columns so that selected columns appear first:\n\ndf.select(ti.move_cols_to_start(\"c\", \"b\"))\n\n\nshape: (3, 3)cbaf64stri644.4\"x\"15.5\"y\"26.6\"z\"3\n\n\nReorder by data type:\n\ndf.select(ti.move_cols_to_start([pl.Float64, pl.String]))\n\n\nshape: (3, 3)bcastrf64i64\"x\"4.41\"y\"5.52\"z\"6.63\n\n\nNote that when selecting by data type, the moved columns will follow the original order in the DataFrame schema.\n\ndf.select(ti.move_cols_to_start([pl.String, pl.Float64]))\n\n\nshape: (3, 3)bcastrf64i64\"x\"4.41\"y\"5.52\"z\"6.63",
    "crumbs": [
      "API Reference",
      "General",
      "move_cols_to_start"
    ]
  },
  {
    "objectID": "reference/is_every_nth_row.html",
    "href": "reference/is_every_nth_row.html",
    "title": "is_every_nth_row",
    "section": "",
    "text": "is_every_nth_row(n, offset=0, *, name='bool_nth_row')\nReturns a Polars expression that is True for every n-th row (index modulo n equals 0).\nis_every_nth_row() can be seen as the complement of pl.Expr.gather_every().\nWhile pl.Expr.gather_every() is typically used in a select() context and may return a DataFrame with fewer rows, is_every_nth_row() produces a predicate expression that can be used with select() or with_columns() to preserve the original row structure for further processing, or with filter() to achieve the same result as pl.Expr.gather_every().",
    "crumbs": [
      "API Reference",
      "General",
      "is_every_nth_row"
    ]
  },
  {
    "objectID": "reference/is_every_nth_row.html#parameters",
    "href": "reference/is_every_nth_row.html#parameters",
    "title": "is_every_nth_row",
    "section": "Parameters",
    "text": "Parameters\n\nn : int\n\nThe interval to use for row selection. Should be positive.\n\noffset : int = 0\n\nStart the index at this offset. Cannot be negative.\n\nname : str = 'bool_nth_row'\n\nThe name of the resulting column.",
    "crumbs": [
      "API Reference",
      "General",
      "is_every_nth_row"
    ]
  },
  {
    "objectID": "reference/is_every_nth_row.html#returns",
    "href": "reference/is_every_nth_row.html#returns",
    "title": "is_every_nth_row",
    "section": "Returns",
    "text": "Returns\n\n : pl.Expr\n\nA boolean Polars expression.",
    "crumbs": [
      "API Reference",
      "General",
      "is_every_nth_row"
    ]
  },
  {
    "objectID": "reference/is_every_nth_row.html#examples",
    "href": "reference/is_every_nth_row.html#examples",
    "title": "is_every_nth_row",
    "section": "Examples",
    "text": "Examples\n\nDataFrame Context\nMark every second row:\n\nimport polars as pl\nimport turtle_island as ti\n\npl.Config.set_fmt_table_cell_list_len(10)\ndf = pl.DataFrame({\"x\": [1, 2, 3, 4, 5]})\ndf.with_columns(ti.is_every_nth_row(2))\n\n\nshape: (5, 2)xbool_nth_rowi64bool1true2false3true4false5true\n\n\nTo invert the result, use either the ~ operator or pl.Expr.not_():\n\ndf.with_columns(\n    ~ti.is_every_nth_row(2).alias(\"~2\"),\n    ti.is_every_nth_row(2).not_().alias(\"not_2\"),\n)\n\n\nshape: (5, 3)x~2not_2i64boolbool1falsefalse2truetrue3falsefalse4truetrue5falsefalse\n\n\nUse offset= to shift the starting index:\n\ndf.with_columns(ti.is_every_nth_row(3, 1))\n\n\nshape: (5, 2)xbool_nth_rowi64bool1false2true3false4false5true\n\n\nFor reference, here‚Äôs the output using pl.Expr.gather_every():\n\ndf.select(pl.col(\"x\").gather_every(3, 1))\n\n\nshape: (2, 1)xi6425\n\n\nYou can also combine multiple is_every_nth_row() expressions to construct more complex row selections. For example, to select rows that are part of every second or every third row:\n\ndf.select(\n    ti.is_every_nth_row(2).alias(\"2\"),\n    ti.is_every_nth_row(3).alias(\"3\"),\n    ti.is_every_nth_row(2).or_(ti.is_every_nth_row(3)).alias(\"2_or_3\")\n)\n\n\nshape: (5, 3)232_or_3boolboolbooltruetruetruefalsefalsefalsetruefalsetruefalsetruetruetruefalsetrue\n\n\n\n\nList Namespace Context\n\n\n\n\n\n\nTipWorking with Lists as Series\n\n\n\n\n\nIn the list namespace, it may be easier to think of each row as an element in a list. Conceptually, you‚Äôre working with a pl.Series, where each row corresponds to one item in the list.\n\n\n\nMark every second element:\n\ndf2 = pl.DataFrame(\n    {\n        \"x\": [[1, 2, 3, 4], [5, 6, 7, 8]],\n        \"y\": [[9, 10, 11, 12], [13, 14, 15, 16]],\n    }\n)\ndf2.with_columns(pl.all().list.eval(ti.is_every_nth_row(2)))\n\n\nshape: (2, 2)xylist[bool]list[bool][true, false, true, false][true, false, true, false][true, false, true, false][true, false, true, false]",
    "crumbs": [
      "API Reference",
      "General",
      "is_every_nth_row"
    ]
  },
  {
    "objectID": "reference/bucketize_lit.html",
    "href": "reference/bucketize_lit.html",
    "title": "bucketize_lit",
    "section": "",
    "text": "bucketize_lit(*items, return_dtype=None)\nReturns a Polars expression that assigns a label to each row based on its index, cycling through the provided items in a round-robin fashion.\nbucketize_lit() is a simplified version of bucketize(), designed for common use cases involving literal values. For more advanced scenarios, consider using bucketize() directly.",
    "crumbs": [
      "API Reference",
      "General",
      "bucketize_lit"
    ]
  },
  {
    "objectID": "reference/bucketize_lit.html#parameters",
    "href": "reference/bucketize_lit.html#parameters",
    "title": "bucketize_lit",
    "section": "Parameters",
    "text": "Parameters\n\nitems : Any = ()\n\nLiteral values to cycle through. You can provide these either as multiple separate arguments or as a single iterable containing the values. All items must be of the same type, and at least two items are required. See the table below for supported types and their conversions.\n\nreturn_dtype : pl.DataType | pl.DataTypeExpr | None = None\n\nAn optional Polars data type to cast the resulting expression to.",
    "crumbs": [
      "API Reference",
      "General",
      "bucketize_lit"
    ]
  },
  {
    "objectID": "reference/bucketize_lit.html#returns",
    "href": "reference/bucketize_lit.html#returns",
    "title": "bucketize_lit",
    "section": "Returns",
    "text": "Returns\n\n : pl.Expr\n\nA Polars expression that cycles through the provided values based on the row index modulo.",
    "crumbs": [
      "API Reference",
      "General",
      "bucketize_lit"
    ]
  },
  {
    "objectID": "reference/bucketize_lit.html#supported-type-conversions",
    "href": "reference/bucketize_lit.html#supported-type-conversions",
    "title": "bucketize_lit",
    "section": "Supported Type Conversions",
    "text": "Supported Type Conversions\n\n\n\nPython Type\nConverted To\n\n\n\n\nbool\npl.Boolean\n\n\ndatetime.datetime\npl.Datetime\n\n\ndatetime.date\npl.Date\n\n\ndatetime.time\npl.Time\n\n\ndatetime.timedelta\npl.Duration\n\n\nint\npl.Int64\n\n\nfloat\npl.Float64\n\n\nstr\npl.String\n\n\nlist, tuple\npl.List\n\n\nOthers\nno cast involved",
    "crumbs": [
      "API Reference",
      "General",
      "bucketize_lit"
    ]
  },
  {
    "objectID": "reference/bucketize_lit.html#examples",
    "href": "reference/bucketize_lit.html#examples",
    "title": "bucketize_lit",
    "section": "Examples",
    "text": "Examples\n\nDataFrame Context\nCycle through boolean values to mark alternating rows:\n\nimport polars as pl\nimport turtle_island as ti\n\npl.Config.set_fmt_table_cell_list_len(10)\ndf = pl.DataFrame({\"x\": [1, 2, 3, 4, 5]})\ndf.with_columns(ti.bucketize_lit(True, False).alias(\"bucketized\"))\n\n\nshape: (5, 2)xbucketizedi64bool1true2false3true4false5true\n\n\nCast the result to a specific data type using return_dtype=:\n\ndf.with_columns(\n    ti.bucketize_lit(True, False, return_dtype=pl.Int64).alias(\"bucketized\")\n)\n\n\nshape: (5, 2)xbucketizedi64i641120314051\n\n\n\n\nList Namespace Context\n\n\n\n\n\n\nTipWorking with Lists as Series\n\n\n\n\n\nIn the list namespace, it may be easier to think of each row as an element in a list. Conceptually, you‚Äôre working with a pl.Series, where each row corresponds to one item in the list.\n\n\n\nCycle through boolean values to mark alternating elements:\n\ndf2 = pl.DataFrame(\n    {\n        \"x\": [[1, 2, 3, 4], [5, 6, 7, 8]],\n        \"y\": [[9, 10, 11, 12], [13, 14, 15, 16]],\n    }\n)\ndf2.with_columns(\n    pl.all().list.eval(ti.bucketize_lit(True, False))\n)\n\n\nshape: (2, 2)xylist[bool]list[bool][true, false, true, false][true, false, true, false][true, false, true, false][true, false, true, false]",
    "crumbs": [
      "API Reference",
      "General",
      "bucketize_lit"
    ]
  }
]